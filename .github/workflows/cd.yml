name: ðŸš€ CD Pipeline with Zero Downtime

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  push:
    branches:
      # - main
      - sabbir

jobs:
  build-and-push:
    name: Build & Push Docker Image ðŸ—ï¸
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}

    outputs:
      package_name: ${{ steps.package.outputs.package_name }}
      package_version: ${{ steps.package.outputs.package_version }}
      image_tag: ${{ steps.package.outputs.image_tag }}

    steps:
      - name: Checkout Code ðŸ“¥
        uses: actions/checkout@v4

      - name: Log in to Docker Hub ðŸ”‘
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Extract Package Name & Version ðŸ“¦
        id: package
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          IMAGE_TAG="${{ secrets.DOCKER_USERNAME }}/${PACKAGE_NAME}:${PACKAGE_VERSION}"
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create .env file ðŸ“„
        run: |
          echo "PACKAGE_VERSION=${{ env.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ env.package_name }}" >> .env
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Build Docker Image ðŸ”¨
        run: docker compose --profile prod build

      - name: Push Docker Image ðŸš€
        run: |
          docker compose --profile prod push
          echo "âœ… Docker image ${{ env.image_tag }} pushed successfully!"

      - name: Clean up .env ðŸ§¹
        if: always()
        run: rm -f .env

  deploy:
    name: Deploy to the VPS with Zero Downtime ðŸ”„
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      PACKAGE_NAME: ${{ needs.build-and-push.outputs.package_name }}
      PACKAGE_VERSION: ${{ needs.build-and-push.outputs.package_version }}
      IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}

    steps:
      - name: Checkout Code ðŸ“¥
        uses: actions/checkout@v4

      - name: Extract Package Info ðŸ“¦
        id: package
        run: |
          PACKAGE_NAME=${{ needs.build-and-push.outputs.package_name }}
          PACKAGE_VERSION=${{ needs.build-and-push.outputs.package_version }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV

      # ðŸ” Load SSH key into agent
      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SABBIR_VPS_KEY }}

      - name: Create .env file ðŸ“„
        run: |
          echo "PACKAGE_VERSION=${{ env.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ env.package_name }}" >> .env
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Copy Files to Server ðŸ“¦
        run: |
          # Create app directory if it doesn't exist
          ssh -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "mkdir -p ~/${{ env.package_name }} ~/${{ env.package_name }}/scripts"
            
          # Copy deployment files
          scp -o StrictHostKeyChecking=no docker-compose.yaml ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/
          scp -o StrictHostKeyChecking=no .env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/
          scp -o StrictHostKeyChecking=no Dockerfile ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/

          # Copy scripts
          scp -o StrictHostKeyChecking=no scripts/deploy.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/scripts/
          scp -o StrictHostKeyChecking=no scripts/health-check.js ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/scripts/

          # Make scripts executable
          ssh -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "chmod +x ~/${{ env.package_name }}/scripts/deploy.sh"

      - name: Zero-downtime Deployment ðŸš€
        env:
          IMAGE_NAME: ${{ env.package_name }}
          IMAGE_VERSION: ${{ env.package_version }}
        run: |
          ssh -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'

          cd ~/${{ env.package_name }}

          # Install Docker Compose CLI if needed
          if [ ! -f ~/.docker/cli-plugins/docker-compose ]; then
            mkdir -p ~/.docker/cli-plugins/
            curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
            chmod +x ~/.docker/cli-plugins/docker-compose
          fi

          # Install jq if not already installed (needed for deployment script)
          if ! command -v jq &>/dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Log in to Docker Hub for private image
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

          # Ensure user has Docker permissions
          sudo usermod -aG docker $USER

          # Make sure ports are allowed in firewall
          sudo ufw allow 5055
          sudo ufw allow 5432
          sudo ufw allow 6379

          # Pull the new image
          docker pull ${{ env.image_tag }}

          # Execute zero-downtime deployment script
          ./scripts/deploy.sh --version ${{ env.package_version }}

          # Check deployment status
          if [ $? -ne 0 ]; then
            echo "Deployment failed! Check logs for details."
            exit 1
          fi

          # Verify containers
          docker ps --filter "name=${{ env.package_name }}"

          # Log out from Docker Hub
          docker logout

          # Clean up unused Docker objects (only dangling images, not volumes)
          docker image prune -f
          EOF

      - name: Verify Deployment âœ…
        run: |
          # Wait a moment for services to stabilize
          sleep 10

          # Check if service is responding
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          cd ~/${{ env.package_name }}
          ./scripts/deploy.sh status
          EOF
