name: üöÄ CD Pipeline with Zero Downtime

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  push:
    branches:
      # - main
      - sabbir

jobs:
  build-and-push:
    name: Build & Push Docker Image üèóÔ∏è
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}

    outputs:
      package_name: ${{ steps.package.outputs.package_name }}
      package_version: ${{ steps.package.outputs.package_version }}
      image_tag: ${{ steps.package.outputs.image_tag }}

    steps:
      - name: Checkout Code üì•
        uses: actions/checkout@v4

      - name: Log in to Docker Hub üîë
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Extract Package Name & Version üì¶
        id: package
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          IMAGE_TAG="${{ secrets.DOCKER_USERNAME }}/${PACKAGE_NAME}:${PACKAGE_VERSION}"
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create .env file üìÑ
        run: |
          echo "PACKAGE_VERSION=${{ env.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ env.package_name }}" >> .env
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Build Docker Image üî®
        run: docker compose --profile prod build

      - name: Push Docker Image üöÄ
        run: |
          docker compose --profile prod push
          echo "‚úÖ Docker image ${{ env.image_tag }} pushed successfully!"

      - name: Clean up .env üßπ
        if: always()
        run: rm -f .env

  deploy:
    name: Deploy to the VPS with Zero Downtime üîÑ
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      PACKAGE_NAME: ${{ needs.build-and-push.outputs.package_name }}
      PACKAGE_VERSION: ${{ needs.build-and-push.outputs.package_version }}
      IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}

    steps:
      - name: Checkout Code üì•
        uses: actions/checkout@v4

      - name: Extract Package Info üì¶
        id: package
        run: |
          PACKAGE_NAME=${{ needs.build-and-push.outputs.package_name }}
          PACKAGE_VERSION=${{ needs.build-and-push.outputs.package_version }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV

      # - name: Setup SSH üîë
      #   run: |
      #     mkdir -p ~/.ssh
      #     echo "${{ secrets.VPS_SSH_PRIVATE_KEY }}" > ~/.ssh/key
      #     chmod 600 ~/.ssh/key
      #     ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      # - name: Test SSH Connection
      #   run: |
      #     ssh -i ~/.ssh/key -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo 'SSH works!'"

      # üîê Setup SSH connection - ROBUST METHOD
      - name: Setup SSH Key and Connection üîë
        run: |
          # Create SSH directory with proper permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Write the private key to a temporary file
          echo "${{ secrets.VPS_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key_raw

          # Clean up the key - remove any Windows line endings and extra whitespace
          tr -d '\r' < ~/.ssh/deploy_key_raw | sed '/^$/d' > ~/.ssh/deploy_key_clean

          # Check if key has proper BEGIN/END markers
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key_clean; then
            echo "‚ùå SSH key is missing proper headers!"
            echo "Your key should start with '-----BEGIN RSA PRIVATE KEY-----' or '-----BEGIN OPENSSH PRIVATE KEY-----'"
            echo ""
            echo "üîß SOLUTION: Generate a new SSH key with this command:"
            echo "ssh-keygen -t rsa -b 4096 -m PEM -f ~/.ssh/vps_deploy_key -N ''"
            echo ""
            echo "Then copy the ENTIRE content including the BEGIN/END lines to your GitHub secret."
            exit 1
          fi

          # Copy cleaned key to final location
          cp ~/.ssh/deploy_key_clean ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Try to get key info to validate format
          echo "üîç Validating SSH key..."
          if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
            echo "‚úÖ SSH key format is valid!"
          else
            echo "‚ö†Ô∏è  Key format may be OpenSSH format, attempting conversion..."
            
            # Create backup
            cp ~/.ssh/deploy_key ~/.ssh/deploy_key.backup
            
            # Try different conversion methods
            if ssh-keygen -p -m PEM -f ~/.ssh/deploy_key -N "" -P "" 2>/dev/null; then
              echo "‚úÖ Successfully converted OpenSSH key to RSA PEM format"
            elif ssh-keygen -p -m RFC4716 -f ~/.ssh/deploy_key -N "" -P "" 2>/dev/null; then
              echo "‚úÖ Successfully converted key to RFC4716 format"
            else
              echo "‚ùå All conversion attempts failed!"
              echo ""
              echo "üîß SOLUTION REQUIRED:"
              echo "1. On your local machine or server, run:"
              echo "   ssh-keygen -t rsa -b 4096 -m PEM -f ~/.ssh/new_vps_key -N ''"
              echo ""
              echo "2. Copy the public key to your server:"
              echo "   ssh-copy-id -i ~/.ssh/new_vps_key.pub user@your-server"
              echo ""
              echo "3. Copy the PRIVATE key content to GitHub secrets:"
              echo "   cat ~/.ssh/new_vps_key"
              echo ""
              echo "4. Make sure to copy the ENTIRE key including:"
              echo "   -----BEGIN RSA PRIVATE KEY-----"
              echo "   [key content]"
              echo "   -----END RSA PRIVATE KEY-----"
              exit 1
            fi
          fi

          # Validate the key works by checking it again
          if ssh-keygen -l -f ~/.ssh/deploy_key >/dev/null 2>&1; then
            echo "‚úÖ Final key validation successful"
          else
            echo "‚ùå Final key validation failed"
            exit 1
          fi

          # Add server to known hosts
          echo "üîó Adding server to known hosts..."
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Test SSH connection with the key
          echo "üß™ Testing SSH connection..."
          if ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o BatchMode=yes ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo 'SSH test successful'" 2>/dev/null; then
            echo "‚úÖ SSH connection test passed!"
          else
            echo "‚ùå SSH connection test failed!"
            echo ""
            echo "üîß Troubleshooting steps:"
            echo "1. Verify VPS_HOST, VPS_USER, and VPS_SSH_PRIVATE_KEY secrets are correct"
            echo "2. Ensure the public key is properly added to ~/.ssh/authorized_keys on the server"
            echo "3. Check if SSH service is running on the server"
            echo "4. Verify firewall allows SSH connections (port 22)"
            exit 1
          fi

          # Clean up temporary files
          rm -f ~/.ssh/deploy_key_raw ~/.ssh/deploy_key_clean ~/.ssh/deploy_key.backup

          echo "üéâ SSH setup completed successfully!"

      - name: Create .env file üìÑ
        run: |
          echo "PACKAGE_VERSION=${{ env.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ env.package_name }}" >> .env
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Copy Files to Server üì¶
        run: |
          # Determine SSH command based on setup
          if [ "$SSH_USE_DIRECT" = "true" ]; then
            SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
            SCP_CMD="scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
          else
            SSH_CMD="ssh -o StrictHostKeyChecking=no"
            SCP_CMD="scp -o StrictHostKeyChecking=no"
          fi

          echo "Creating directories on server..."
          $SSH_CMD ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "mkdir -p ~/${{ env.package_name }} ~/${{ env.package_name }}/scripts"

          echo "Copying deployment files..."
          $SCP_CMD docker-compose.yaml ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/
          $SCP_CMD .env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/
          $SCP_CMD Dockerfile ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/

          echo "Copying scripts..."
          $SCP_CMD scripts/deploy.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/scripts/
          $SCP_CMD scripts/health-check.js ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ env.package_name }}/scripts/

          echo "Making scripts executable..."
          $SSH_CMD ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "chmod +x ~/${{ env.package_name }}/scripts/deploy.sh"

          echo "‚úÖ Files copied successfully"

      - name: Zero-downtime Deployment üöÄ
        env:
          IMAGE_NAME: ${{ env.package_name }}
          IMAGE_VERSION: ${{ env.package_version }}
        run: |
          # Determine SSH command
          if [ "$SSH_USE_DIRECT" = "true" ]; then
            SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
          else
            SSH_CMD="ssh -o StrictHostKeyChecking=no"
          fi

          echo "Starting zero-downtime deployment..."

          $SSH_CMD ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          set -e  # Exit on any error

          cd ~/${{ env.package_name }}

          echo "üèÅ Starting deployment process..."

          # Install Docker Compose CLI if needed
          if [ ! -f ~/.docker/cli-plugins/docker-compose ]; then
            echo "üì¶ Installing Docker Compose..."
            mkdir -p ~/.docker/cli-plugins/
            curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
            chmod +x ~/.docker/cli-plugins/docker-compose
            echo "‚úÖ Docker Compose installed"
          fi

          # Install jq if not already installed
          if ! command -v jq &>/dev/null; then
            echo "üì¶ Installing jq..."
            sudo apt-get update && sudo apt-get install -y jq
            echo "‚úÖ jq installed"
          fi

          # Log in to Docker Hub
          echo "üîë Logging into Docker Hub..."
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

          # Ensure user has Docker permissions
          echo "üîß Setting up Docker permissions..."
          sudo usermod -aG docker $USER || true

          # Setup firewall rules
          echo "üî• Configuring firewall..."
          sudo ufw allow 5055 || true
          sudo ufw allow 5432 || true  
          sudo ufw allow 6379 || true

          # Pull the new image
          echo "üì• Pulling Docker image: ${{ env.image_tag }}"
          if docker pull ${{ env.image_tag }}; then
            echo "‚úÖ Image pulled successfully"
          else
            echo "‚ùå Failed to pull image"
            exit 1
          fi

          # Check if deploy script exists
          if [ ! -f "./scripts/deploy.sh" ]; then
            echo "‚ùå Deploy script not found!"
            echo "Available files:"
            ls -la scripts/ || echo "No scripts directory"
            exit 1
          fi

          # Make sure script is executable
          chmod +x ./scripts/deploy.sh

          # Execute zero-downtime deployment script
          echo "üöÄ Executing deployment script..."
          if ./scripts/deploy.sh --version ${{ env.package_version }}; then
            echo "‚úÖ Deployment script executed successfully"
          else
            echo "‚ùå Deployment script failed"
            echo "Container status:"
            docker ps -a --filter "name=${{ env.package_name }}" || true
            echo "Recent logs:"
            docker logs --tail 50 "${{ env.package_name }}_app_1" 2>/dev/null || true
            exit 1
          fi

          # Verify containers are running
          echo "üîç Verifying deployment..."
          if docker ps --filter "name=${{ env.package_name }}" | grep -q "${{ env.package_name }}"; then
            echo "‚úÖ Containers are running"
            docker ps --filter "name=${{ env.package_name }}"
          else
            echo "‚ùå No containers found running"
            docker ps -a --filter "name=${{ env.package_name }}"
            exit 1
          fi

          # Log out from Docker Hub
          docker logout

          # Clean up unused Docker objects (only dangling images)
          echo "üßπ Cleaning up unused Docker images..."
          docker image prune -f

          echo "üéâ Deployment completed successfully!"
          EOF

      - name: Verify Deployment ‚úÖ
        run: |
          # Determine SSH command
          if [ "$SSH_USE_DIRECT" = "true" ]; then
            SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
          else
            SSH_CMD="ssh -o StrictHostKeyChecking=no"
          fi

          echo "‚è≥ Waiting for services to stabilize..."
          sleep 15

          echo "üîç Verifying deployment status..."

          $SSH_CMD ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          cd ~/${{ env.package_name }}

          echo "=== Container Status ==="
          docker ps --filter "name=${{ env.package_name }}"

          echo "=== Health Check ==="
          if [ -f "./scripts/deploy.sh" ]; then
            ./scripts/deploy.sh status
          else
            echo "Deploy script not found, checking manually..."
            
            # Try to curl the health endpoint
            if curl -f http://localhost:5055/health 2>/dev/null; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ö†Ô∏è  Health check endpoint not responding"
              echo "Container logs:"
              docker logs --tail 20 "${{ env.package_name }}_app_1" 2>/dev/null || echo "No logs available"
            fi
          fi

          echo "=== Final Status ==="
          if docker ps --filter "name=${{ env.package_name }}" | grep -q "Up"; then
            echo "üéâ Deployment verification successful!"
          else
            echo "‚ùå Deployment verification failed!"
            exit 1
          fi
          EOF

      - name: Cleanup SSH üßπ
        if: always()
        run: |
          # Clean up SSH files
          rm -f ~/.ssh/deploy_key ~/.ssh/deploy_key.orig
          rm -f .env
