name: 🚀 CD Pipeline with Zero Downtime

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  push:
    branches:
      # - main
      - sabbir

jobs:
  build-and-push:
    name: Build & Push Docker Image 🏗️
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}

    outputs:
      package_name: ${{ steps.extract.outputs.package_name }}
      package_version: ${{ steps.extract.outputs.package_version }}
      image_tag: ${{ steps.extract.outputs.image_tag }}

    steps:
      - name: Validate Required Secrets 🔐
        run: |
          echo "🔍 Validating required secrets and environment..."

          # Check if secrets are available (they will be masked, but we can check if they're set)
          MISSING_SECRETS=0

          if [ -z "${{ secrets.DOCKER_USERNAME }}" ]; then
            echo "❌ DOCKER_USERNAME secret is not set"
            MISSING_SECRETS=$((MISSING_SECRETS + 1))
          else
            echo "✅ DOCKER_USERNAME secret is configured"
          fi

          if [ -z "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "❌ DOCKER_PASSWORD secret is not set"
            MISSING_SECRETS=$((MISSING_SECRETS + 1))
          else
            echo "✅ DOCKER_PASSWORD secret is configured"
          fi

          if [ $MISSING_SECRETS -gt 0 ]; then
            echo "❌ $MISSING_SECRETS required secret(s) are missing"
            echo "Please configure the missing secrets in your GitHub repository settings"
            exit 1
          fi

          echo "✅ All required secrets are properly configured"

      - name: Checkout Code 📥
        uses: actions/checkout@v4

      - name: Validate Package Configuration 📦
        run: |
          echo "🔍 Validating package.json..."

          if [ ! -f "package.json" ]; then
            echo "❌ package.json not found in repository root"
            exit 1
          fi

          # Test if we can read package.json and extract required fields
          if ! node -e "const pkg = require('./package.json'); console.log('Package:', pkg.name, 'Version:', pkg.version)" 2>/dev/null; then
            echo "❌ Failed to read package.json or missing name/version fields"
            exit 1
          fi

          echo "✅ package.json is valid and readable"

      - name: Extract Package Info 📦
        id: extract
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          set -e  # Exit immediately if any command fails
          
          echo "🔍 Starting package extraction process..."
          
          # Debug environment variables
          echo "=== ENVIRONMENT DEBUG ==="
          echo "DOCKER_USERNAME length: ${#DOCKER_USERNAME}"
          echo "DOCKER_PASSWORD set: $([ -n "$DOCKER_PASSWORD" ] && echo 'YES' || echo 'NO')"
          echo "========================="
          
          # Validate that required secrets are available
          if [ -z "$DOCKER_USERNAME" ]; then
            echo "❌ ERROR: DOCKER_USERNAME environment variable is empty"
            echo "This means the DOCKER_USERNAME secret is not set in GitHub repository settings"
            exit 1
          fi

          if [ -z "$DOCKER_PASSWORD" ]; then
            echo "❌ ERROR: DOCKER_PASSWORD environment variable is empty"
            echo "This means the DOCKER_PASSWORD secret is not set in GitHub repository settings"
            exit 1
          fi

          echo "✅ Docker credentials validation passed"

          # Extract from package.json
          echo "📦 Extracting package information from package.json..."
          
          PACKAGE_NAME=$(node -p "require('./package.json').name" 2>/dev/null)
          if [ $? -ne 0 ] || [ -z "$PACKAGE_NAME" ]; then
            echo "❌ ERROR: Failed to extract package name from package.json"
            exit 1
          fi
          
          PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null)
          if [ $? -ne 0 ] || [ -z "$PACKAGE_VERSION" ]; then
            echo "❌ ERROR: Failed to extract package version from package.json"
            exit 1
          fi
          
          # Construct image tag
          IMAGE_TAG="${DOCKER_USERNAME}/${PACKAGE_NAME}:${PACKAGE_VERSION}"
          
          # Comprehensive debug output
          echo "=== EXTRACTED VALUES ==="
          echo "PACKAGE_NAME: '$PACKAGE_NAME'"
          echo "PACKAGE_VERSION: '$PACKAGE_VERSION'"
          echo "DOCKER_USERNAME: '$(echo $DOCKER_USERNAME | sed 's/./*/g')' (masked)"
          echo "IMAGE_TAG: '$IMAGE_TAG'"
          echo "========================="

          # Final validation
          if [ -z "$PACKAGE_NAME" ]; then
            echo "❌ ERROR: PACKAGE_NAME is empty after extraction"
            exit 1
          fi

          if [ -z "$PACKAGE_VERSION" ]; then
            echo "❌ ERROR: PACKAGE_VERSION is empty after extraction"
            exit 1
          fi
          
          if [ -z "$DOCKER_USERNAME" ]; then
            echo "❌ ERROR: DOCKER_USERNAME is empty"
            exit 1
          fi

          if [ -z "$IMAGE_TAG" ]; then
            echo "❌ ERROR: IMAGE_TAG is empty after construction"
            echo "DOCKER_USERNAME: '$DOCKER_USERNAME'"
            echo "PACKAGE_NAME: '$PACKAGE_NAME'"
            echo "PACKAGE_VERSION: '$PACKAGE_VERSION'"
            exit 1
          fi

          echo "✅ All extracted values are valid"

          # Set outputs with additional validation
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          # Verify outputs were written
          echo "🔍 Verifying outputs were set..."
          if grep -q "package_name=$PACKAGE_NAME" $GITHUB_OUTPUT && \
             grep -q "package_version=$PACKAGE_VERSION" $GITHUB_OUTPUT && \
             grep -q "image_tag=$IMAGE_TAG" $GITHUB_OUTPUT; then
            echo "✅ All outputs successfully written to GITHUB_OUTPUT"
          else
            echo "❌ ERROR: Failed to write outputs to GITHUB_OUTPUT"
            echo "GITHUB_OUTPUT contents:"
            cat $GITHUB_OUTPUT || echo "Could not read GITHUB_OUTPUT file"
            exit 1
          fi

          echo "✅ Package extraction completed successfully"

      - name: Log in to Docker Hub 🔑
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          echo "🔑 Logging into Docker Hub..."
          echo "Username: $(echo $DOCKER_USERNAME | sed 's/./*/g')" # Masked for security
          
          if echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin; then
            echo "✅ Successfully logged into Docker Hub"
          else
            echo "❌ Failed to log into Docker Hub"
            echo "Please check your DOCKER_USERNAME and DOCKER_PASSWORD secrets"
            exit 1
          fi

      - name: Create .env file 📄
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          echo "📄 Creating .env file for Docker build..."
          echo "PACKAGE_VERSION=${{ steps.extract.outputs.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ steps.extract.outputs.package_name }}" >> .env
          echo "DOCKER_USERNAME=$DOCKER_USERNAME" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Build Docker Image 🔨
        run: docker compose --profile prod build

      - name: Push Docker Image 🚀
        run: |
          docker compose --profile prod push
          echo "✅ Docker image ${{ steps.extract.outputs.image_tag }} pushed successfully!"

      - name: Clean up .env 🧹
        if: always()
        run: rm -f .env

  deploy:
    name: Deploy to VPS with Zero Downtime 🔄
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code 📥
        uses: actions/checkout@v4

      - name: Verify Build Outputs 🔍
        run: |
          echo "🔍 Verifying build job outputs..."
          echo "=== BUILD JOB OUTPUTS ==="
          echo "package_name: '${{ needs.build-and-push.outputs.package_name }}'"
          echo "package_version: '${{ needs.build-and-push.outputs.package_version }}'"
          echo "image_tag: '${{ needs.build-and-push.outputs.image_tag }}'"
          echo "========================="

          # Check build job status first
          echo "Build job result: ${{ needs.build-and-push.result }}"
          if [ "${{ needs.build-and-push.result }}" != "success" ]; then
            echo "❌ ERROR: Build job did not succeed. Status: ${{ needs.build-and-push.result }}"
            exit 1
          fi

          # Validate individual outputs with detailed error messages
          ERRORS=0

          if [ -z "${{ needs.build-and-push.outputs.package_name }}" ]; then
            echo "❌ ERROR: package_name is empty - build job failed to extract package name from package.json"
            ERRORS=$((ERRORS + 1))
          fi

          if [ -z "${{ needs.build-and-push.outputs.package_version }}" ]; then
            echo "❌ ERROR: package_version is empty - build job failed to extract version from package.json"
            ERRORS=$((ERRORS + 1))
          fi

          if [ -z "${{ needs.build-and-push.outputs.image_tag }}" ]; then
            echo "❌ ERROR: image_tag is empty - build job failed to construct Docker image tag"
            echo "This usually means DOCKER_USERNAME secret is not set or the image tag construction failed"
            ERRORS=$((ERRORS + 1))
          fi

          if [ $ERRORS -gt 0 ]; then
            echo "❌ Found $ERRORS error(s) in build outputs"
            echo "Please check the build-and-push job logs for more details"
            exit 1
          fi

          echo "✅ All outputs are valid and ready for deployment"

      - name: Setup SSH 🔐
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.VPS_SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

          cat > ~/.ssh/config << EOF
          Host deploy-server
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Test SSH Connection 🚀
        run: ssh deploy-server "echo 'SSH connection successful'"

      - name: Create .env file 📄
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          echo "📄 Creating deployment .env file..."
          echo "PACKAGE_VERSION=${{ needs.build-and-push.outputs.package_version }}" >> .env
          echo "PACKAGE_NAME=${{ needs.build-and-push.outputs.package_name }}" >> .env
          echo "DOCKER_USERNAME=$DOCKER_USERNAME" >> .env
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}" >> .env
          echo "BASE_URL=${{ secrets.BASE_URL }}" >> .env
          echo "MAIL_USER=${{ secrets.MAIL_USER }}" >> .env
          echo "MAIL_PASS=${{ secrets.MAIL_PASS }}" >> .env
          echo "SUPER_ADMIN_EMAIL=${{ secrets.SUPER_ADMIN_EMAIL }}" >> .env
          echo "SUPER_ADMIN_PASS=${{ secrets.SUPER_ADMIN_PASS }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}" >> .env
          echo "TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}" >> .env
          echo "TWILIO_PHONE_NUMBER=${{ secrets.TWILIO_PHONE_NUMBER }}" >> .env

      - name: Copy Files to Server 📦
        run: |
          echo "Creating directories..."
          ssh deploy-server "mkdir -p ~/${{ needs.build-and-push.outputs.package_name }}/scripts"

          echo "Copying files..."
          scp -i ~/.ssh/deploy_key docker-compose.yaml ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ needs.build-and-push.outputs.package_name }}/
          scp -i ~/.ssh/deploy_key .env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ needs.build-and-push.outputs.package_name }}/
          scp -i ~/.ssh/deploy_key Dockerfile ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ needs.build-and-push.outputs.package_name }}/
          scp -i ~/.ssh/deploy_key scripts/deploy.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ needs.build-and-push.outputs.package_name }}/scripts/
          scp -i ~/.ssh/deploy_key scripts/health-check.js ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:~/${{ needs.build-and-push.outputs.package_name }}/scripts/

          ssh deploy-server "chmod +x ~/${{ needs.build-and-push.outputs.package_name }}/scripts/deploy.sh"
          echo "✅ Files copied successfully"

      - name: Deploy Application 🚀
        run: |
          echo "Starting deployment..."
          echo "Package: ${{ needs.build-and-push.outputs.package_name }}"
          echo "Version: ${{ needs.build-and-push.outputs.package_version }}"
          echo "Image: ${{ needs.build-and-push.outputs.image_tag }}"

          ssh deploy-server bash << 'DEPLOY_EOF'
          set -e

          # Set variables (using the exact values from GitHub Actions)
          PACKAGE_NAME="${{ needs.build-and-push.outputs.package_name }}"
          PACKAGE_VERSION="${{ needs.build-and-push.outputs.package_version }}"
          IMAGE_TAG="${{ needs.build-and-push.outputs.image_tag }}"

          echo "=== DEPLOYMENT STARTED ==="
          echo "Package: $PACKAGE_NAME"
          echo "Version: $PACKAGE_VERSION"
          echo "Image: $IMAGE_TAG"
          echo "=============================="

          cd ~/$PACKAGE_NAME

          # Install Docker Compose if needed
          if [ ! -f ~/.docker/cli-plugins/docker-compose ]; then
            echo "Installing Docker Compose..."
            mkdir -p ~/.docker/cli-plugins/
            curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
            chmod +x ~/.docker/cli-plugins/docker-compose
          fi

          # Install jq if needed
          if ! command -v jq &>/dev/null; then
            echo "Installing jq..."
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Login to Docker Hub
          echo "Logging into Docker Hub..."
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

          # Set Docker permissions
          sudo usermod -aG docker $USER || true

          # Configure firewall
          sudo ufw allow 5055 || true
          sudo ufw allow 5432 || true
          sudo ufw allow 6379 || true

          # Pull the Docker image
          echo "Pulling Docker image: $IMAGE_TAG"
          if docker pull "$IMAGE_TAG"; then
            echo "✅ Image pulled successfully"
          else
            echo "❌ Failed to pull image: $IMAGE_TAG"
            exit 1
          fi

          # Verify deploy script exists
          if [ ! -f "./scripts/deploy.sh" ]; then
            echo "❌ deploy.sh not found"
            ls -la scripts/ || echo "No scripts directory"
            exit 1
          fi

          # Make script executable
          chmod +x ./scripts/deploy.sh

          # Run deployment
          echo "Executing deployment script..."
          if ./scripts/deploy.sh --version "$PACKAGE_VERSION"; then
            echo "✅ Deployment successful"
          else
            echo "❌ Deployment failed"
            echo "Container status:"
            docker ps -a --filter "name=$PACKAGE_NAME"
            echo "Container logs:"
            docker logs --tail 50 "${PACKAGE_NAME}_app_1" 2>/dev/null || echo "No logs"
            exit 1
          fi

          # Verify containers are running
          if docker ps --filter "name=$PACKAGE_NAME" | grep -q "$PACKAGE_NAME"; then
            echo "✅ Containers are running"
            docker ps --filter "name=$PACKAGE_NAME"
          else
            echo "❌ No containers running"
            docker ps -a --filter "name=$PACKAGE_NAME"
            exit 1
          fi

          # Cleanup
          docker logout
          docker image prune -f

          echo "🎉 DEPLOYMENT COMPLETED SUCCESSFULLY!"
          DEPLOY_EOF

      - name: Verify Deployment ✅
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15

          echo "Verifying deployment..."
          ssh deploy-server bash << 'VERIFY_EOF'
          PACKAGE_NAME="${{ needs.build-and-push.outputs.package_name }}"
          cd ~/$PACKAGE_NAME

          echo "=== Container Status ==="
          docker ps --filter "name=$PACKAGE_NAME"

          echo "=== Health Check ==="
          if [ -f "./scripts/deploy.sh" ]; then
            ./scripts/deploy.sh status
          else
            echo "Checking health manually..."
            if curl -f http://localhost:5055/health 2>/dev/null; then
              echo "✅ Health check passed"
            else
              echo "⚠️ Health check failed"
              docker logs --tail 20 "${PACKAGE_NAME}_app_1" 2>/dev/null || echo "No logs"
            fi
          fi

          echo "=== Final Status ==="
          if docker ps --filter "name=$PACKAGE_NAME" | grep -q "Up"; then
            echo "🎉 Deployment verification successful!"
          else
            echo "❌ Deployment verification failed!"
            exit 1
          fi
          VERIFY_EOF

      - name: Cleanup 🧹
        if: always()
        run: |
          rm -rf ~/.ssh/deploy_key* ~/.ssh/config
          rm -f .env
